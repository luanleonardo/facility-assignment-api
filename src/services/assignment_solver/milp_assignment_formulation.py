import pyomo.environ as pyo
from pyomo.contrib import appsi
from shapely import Point

from config import settings
from src.models import (
    AssignedFacility,
    AssignmentProblem,
    AssignmentSolution,
    SolutionStatus,
)
from src.services import (
    evaluate_assigned_facilities,
    scale_assignment_problem_parameters,
)

TERMINATION_CONDITION_MAPPING = {
    "maxTimeLimit": "Exceeded maximum time limit allowed",
    "maxIterations": "Exceeded maximum number of iterations allowed",
    "minFunctionValue": "Found solution smaller than specified function value",
    "minStepLength": "Step length is smaller than specified limit",
    "globallyOptimal": "Found a globally optimal solution",
    "locallyOptimal": "Found a locally optimal solution",
    "optimal": "Found an optimal solution",
    "maxEvaluations": (
        "Exceeded maximum number of problem evaluations "
        "(e.g., branch and bound nodes)"
    ),
    "other": "Other, uncategorized normal termination",
    "unbounded": "Demonstrated that problem is unbounded",
    "infeasible": "Demonstrated that problem is infeasible",
    "invalidProblem": (
        "The problem setup or characteristics are not valid for the solver"
    ),
    "solverFailure": "Solver failed to terminate correctly",
    "internalSolverError": "Internal solver error",
    "error": "Other error",
    "userInterrupt": "Interrupt signal generated by user",
    "resourceInterrupt": "Interrupt signal in resources used by the solver",
    "licensingProblem": "Problem accessing solver license",
}


def _build_milp_model(
    assignment_problem: AssignmentProblem,
) -> pyo.ConcreteModel:
    """Build the MILP model for the assignment problem"""

    # Create model for the problem
    model = pyo.ConcreteModel(name="Linear_Assignment_Problem")

    # Scale problem parameters to become integer
    scaled_clients, scaled_facilities, scaled_cost_matrix = (
        scale_assignment_problem_parameters(
            assignment_problem=assignment_problem,
            scale_factor=settings.MILP_SCALE_FACTOR,
        )
    )

    # Decision variables
    num_facilities = len(assignment_problem.facilities)
    num_clients = len(assignment_problem.clients)
    model.x = pyo.Var(
        range(num_facilities), range(num_clients), within=pyo.Binary
    )

    # Objective function: minimize total cost_calculator
    model.total_costs = pyo.Objective(
        expr=sum(
            scaled_cost_matrix[i, j] * model.x[i, j]
            for i in range(num_facilities)
            for j in range(num_clients)
        ),
        sense=pyo.minimize,
    )

    # Constraints
    # Each client is assigned to only one facility
    model.client_constraints = pyo.ConstraintList()
    for j in range(num_clients):
        model.client_constraints.add(
            sum(model.x[i, j] for i in range(num_facilities)) == 1
        )

    # Maximum facility demand is respected
    total_demand = sum(client.demand for client in scaled_clients)
    model.maximum_facility_demand_constraints = pyo.ConstraintList()
    for i, facility in enumerate(scaled_facilities):
        max_demand = facility.max_demand or total_demand
        model.maximum_facility_demand_constraints.add(
            sum(
                client.demand * model.x[i, j]
                for j, client in enumerate(scaled_clients)
            )
            <= max_demand
        )

    # Minimum facility demand is respected
    model.minimum_facility_demand_constraints = pyo.ConstraintList()
    for i, facility in enumerate(scaled_facilities):
        model.minimum_facility_demand_constraints.add(
            sum(
                client.demand * model.x[i, j]
                for j, client in enumerate(scaled_clients)
            )
            >= facility.min_demand
        )

    # Exclusive service areas are respected
    exclusive_service_areas = [
        (i, facility.exclusive_service_area)
        for i, facility in enumerate(assignment_problem.facilities)
        if not facility.exclusive_service_area.is_empty
    ]
    if exclusive_service_areas:
        model.exclusive_service_areas_constraints = pyo.ConstraintList()
        for j, client in enumerate(assignment_problem.clients):
            areas_containing_client = [
                i
                for i, area in exclusive_service_areas
                if area.intersects(Point(client.lng, client.lat))
            ]
            if len(areas_containing_client) > 1:
                intersecting_facilities = [
                    assignment_problem.facilities[i].name
                    for i in areas_containing_client
                ]
                raise ValueError(
                    "Impossible solve the problem! "
                    "There is an intersection in the exclusive service areas "
                    f"of the following facilities: {intersecting_facilities}. "
                    "The following coordinates belongs to this intersection: "
                    f"{(client.lat, client.lng)}."
                )
            if len(areas_containing_client) == 1:
                i = areas_containing_client[0]
                model.exclusive_service_areas_constraints.add(
                    model.x[i, j] == 1
                )

    return model


def solve_milp_assignment_formulation(
    assignment_problem: AssignmentProblem,
) -> AssignmentSolution:
    """Solve assignment problem via Mixed Integer Linear Programming"""

    # Build the MILP model
    try:
        model = _build_milp_model(assignment_problem)
    except ValueError as e:
        return AssignmentSolution(
            solution_status=SolutionStatus.INFEASIBLE,
            message=str(e),
        )

    # Solve the problem using the HiGHS solver
    solver = appsi.solvers.Highs()

    # Set HiGHS solver options
    solver.config.time_limit = assignment_problem.solver_time_limit_seconds
    solver.config.load_solution = False

    # Solve the problem
    results = solver.solve(model)

    # Check if the problem was solved
    if results.best_feasible_objective is not None:

        # Load feasible solution into the model
        results.solution_loader.load_vars()

        # Create assigned facilities
        assigned_facilities = [
            AssignedFacility(
                facility=facility,
                assigned_clients=[
                    client
                    for j, client in enumerate(assignment_problem.clients)
                    if model.x[i, j].value == 1
                ],
            )
            for i, facility in enumerate(assignment_problem.facilities)
        ]

        # Evaluate assigned facilities
        evaluated_assigned_facilities = evaluate_assigned_facilities(
            assigned_facilities
        )

        solution_status = (
            SolutionStatus.OPTIMAL
            if results.termination_condition
            == appsi.base.TerminationCondition.optimal
            else SolutionStatus.FEASIBLE
        )

        return AssignmentSolution(
            objective_value=round(
                model.total_costs() / settings.MILP_SCALE_FACTOR
            ),
            assigned_facilities=evaluated_assigned_facilities,
            solution_status=solution_status,
            message=TERMINATION_CONDITION_MAPPING[
                results.termination_condition.name
            ],
        )

    # If the problem was not solved, return infeasible solution
    return AssignmentSolution(
        solution_status=SolutionStatus.INFEASIBLE,
        message=TERMINATION_CONDITION_MAPPING[
            results.termination_condition.name
        ],
    )
